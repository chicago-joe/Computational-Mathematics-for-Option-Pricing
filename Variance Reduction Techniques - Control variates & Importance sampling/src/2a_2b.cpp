// IE525 Computational Homework 4
// UIUC - IE525 - Spring 2019
// 
// Created by Joseph Loss on 4/21/2019
//
// Question 2a & 2b

#include <iostream>
#include <iomanip>
#include <cmath>
#include <cstdlib>
#include <chrono>
#include <random>
#define E 2.718281828459045

using namespace std;

double s0, K, sigma, r, q, deltat;
double T;
int no_of_steps;
int no_of_simulations;


unsigned seed = (unsigned)std::chrono::system_clock::now().time_since_epoch().count();
std::default_random_engine generator(seed);

// u.i.i.d. generator
double get_uniform()
{
	std::uniform_real_distribution<double> distribution(0.0, 1.0);
	double number = distribution(generator);
	return (number);
}

double max(double a, double b)
{
	return (b < a) ? a : b;
}

// returns exponential value of the number in parameter
double exp(double n)
{
	return pow(E, n);
}

// simulate GBM path
double simulatePath_GBM(double s0, double mu, double sigma, double deltat, double T, int flag)
{
	int n = round(T / deltat);     //to ensure n is even
	double *S = new double[n + 1]; //stores simulated stock s0 values
	S[0] = s0;

	for (int i = 1; i <= n / 2; i++)
	{
		double x = get_uniform();
		double y = get_uniform();
		double a = sqrt(-2.0 * log(x)) * cos(6.283185307999998 * y);
		double b = sqrt(-2.0 * log(x)) * sin(6.283185307999998 * y);

		// normally distributed random values generated by Box-Muller are used to simulate asset paths
		S[i] = S[i - 1] * exp((mu - 0.5 * pow(sigma, 2)) * deltat + sigma * sqrt(deltat) * a);
		S[i + 1] = S[i] * exp((mu - 0.5 * pow(sigma, 2)) * deltat + sigma * sqrt(deltat) * b);
	}
	// if Asian options:
	if (flag == 1)
	{
		double avg_price = 0;
		for (int i = 0; i < n; i++)
			avg_price += S[i] / n;
		return avg_price;
	}
	return S[n];
}

/* normal random variate generator */
double box_muller(double m, double s) // mean m, standard deviation s
{
	double x1, x2, w, y1;
	static double y2;
	static int use_last = 0;

	// use value from previous call
	    if (use_last)
	    {
	        y1 = y2;
	        use_last = 0;
	    }
	    else
	{
		do
		{
			x1 = 2.0 * get_uniform() - 1.0;
			x2 = 2.0 * get_uniform() - 1.0;
			w = x1 * x1 + x2 * x2;
		} while (w >= 1.0);

		w = sqrt((-2.0 * log(w)) / w);
		y1 = x1 * w;
		y2 = x2 * w;
		        use_last = 1;
	}
	return (m + y1 * s);
}

double MC_Geometric_Asian_Price(double s0, double K, double sigma, double r, double q, double T, int no_of_simulations, int no_of_steps)
{
	int i, j;
	double G = 0.0, mu = 0.0, deviate;
	double S = 0.0, sum = 0.0, sum2 = 0.0, product = 0.0, payoff = 0.0;
	double call_prc = 0.0, SD = 0.0, SE = 0.0;

	deltat = 1.0 / 252.0;
	mu = r - q - 0.5 * sigma * sigma;

	for (i = 0; i <= no_of_simulations; i++)
	{
		S = s0;
		product = 1;

		for (j = 0; j < no_of_steps; j++)
		{
			deviate = box_muller(0, 1);
				S = S * exp(mu * deltat + sigma * sqrt(deltat) * deviate);
			product *= S;
		}
		// now compute the geometric avg
		G = pow(product, (double)1/no_of_steps);

		payoff = max(G - K, 0);
		sum += payoff;
		sum2 += payoff * payoff;
	}
	call_prc = exp(-r * T) * (sum / no_of_simulations);
	SD = sqrt((sum2 - sum * sum / no_of_simulations) * exp(-2 * r * T) / (no_of_simulations - 1));
	SE = SD / sqrt(no_of_simulations);

	return call_prc;
}

double MC_Arithmetic_Asian_Call_Price(double s0, double K, double sigma, double r, double q, double T, int no_of_simulations, int no_of_steps)
{
	int i, j;
	double A = 0.0, mu = 0.0, deviate;
	double S = 0.0, sum = 0.0, sum1 = 0.0, sum2 = 0.0, payoff = 0.0;
	double call_prc = 0.0, SD = 0.0, SE = 0.0;

	deltat = 1.0 / 252.0;
	mu = r - q - 0.5 * pow(sigma,2);

	// for each simulation
	for (i = 0; i <= no_of_simulations; i++)
	{
		S = s0;
		sum1 = 0;

		for (j = 0; j < no_of_steps; j++)
		{
			deviate = box_muller(0.0, 1.0);
			S = S * exp(mu * deltat + sigma * sqrt(deltat) * deviate);
			sum1 += S;
		}
		A = sum1 / no_of_steps;
		payoff = max(A - K, 0);
		sum += payoff;
		sum2 += payoff * payoff;
	}

	call_prc = exp(-r * T) * (sum / no_of_simulations);
	cout << "Arithmetic Asian Call Price = " << endl << call_prc << endl;

	SD = sqrt((sum2 - sum * sum / no_of_simulations) * exp(-2 * r * T) / (no_of_simulations - 1));
	SE = SD / sqrt(no_of_simulations);
	cout << "SD = " << SD << endl << "SE = " << SE << endl;

	return call_prc;
}

double MC_Arithmetic_Asian_Call_With_Geometric_Control_Variate(double s0, double K, double sigma, double r,	double q, double T, int no_of_simulations, int no_of_steps)
{
	int i, j;
	double geo = 0.0;			// geometric average
	double ave = 0.0;			// arithmetic average
	double SD = 0.0; 
	double SE = 0.0;
	double deviate; 
	double S = 0.0;				// stock price
	double sum = 0.0;			// sum of payoffs
	double sum1 = 0.0;			// sum of squared payoffs
	double product = 0.0;		// product of stock prices
	double payoff = 0.0;		// option payoff
	double call_prc = 0.0;		// option value

	deltat = 1.0 / 252.0;
	double mu = r - q - 0.5*pow(sigma,2);
	
	// for each simulation
	for (i = 0; i <= no_of_simulations; i++)
	{
		S = s0;
		product = 1;
		sum = 0;
		sum1 = 0;

		for (j = 0; j < no_of_steps; j++)
		{
			deviate = box_muller(0.0, 1.0);
			S = S * exp(mu * deltat + sigma * sqrt(deltat) * deviate);
			sum += S;
			product *= S;
		}
		
		ave = sum / no_of_steps;
		geo = pow(product, (double) 1/no_of_steps);
		payoff = max(0, (ave - K) - (geo - K));
		
		sum += payoff;
		sum1 += payoff*payoff;
	}

	call_prc = exp(-r * T) * (sum / no_of_simulations) + MC_Geometric_Asian_Price(s0, K, sigma, r, q, T, no_of_simulations, no_of_steps);

	cout << "AA call price using Geometric Call as Control Variate = " << endl << call_prc << endl << endl;

	SD = sqrt((sum - sum1*sum1/ no_of_simulations) * exp(-2 * r * T) / (no_of_simulations - 1));
	SE = SD / sqrt(no_of_simulations);

	cout << "SD = " << SD << endl;
	cout << "SE = " << SE << endl;

	return call_prc;
}

int main() 
{
	cout << "European Down-and-Out Discrete Barrier Options Pricing via Monte Carlo Simulation" << endl << endl;
	
	// PARAMETERS:
	T = 90.0 / 252.0;
	r = 0.05;
	sigma = 0.4;
	s0 = 40;
	K = 40;
	// q = 0.0;
	no_of_simulations = 10000;
	no_of_steps = 100;
	deltat = 1.0 / 252.0;

	
	cout << "--------------------------------" << endl;
	cout << "PARAMETERS: " << endl;
	cout << "Expiration Time (Years) = " << T << endl;
	cout << "Risk Free Interest Rate = " << r << endl;
	cout << "Volatility (%age of stock value) = " << sigma * 100 << endl;
	cout << "Initial Stock Price = " << s0 << endl;
	cout << "Strike Price = " << K << endl;
	cout << "Number of Trials = " << no_of_simulations << endl;
	cout << "Number of Steps = " << no_of_steps << endl;
	cout << "--------------------------------" << endl << endl;

// Monte Carlo Arithmetic Asian Call Price
	MC_Arithmetic_Asian_Call_Price(s0, K, sigma, r, q, T, no_of_simulations, no_of_steps);
	cout << endl << endl;
	MC_Arithmetic_Asian_Call_With_Geometric_Control_Variate(s0, K, sigma, r, q, T, no_of_simulations, no_of_steps);


	cout << endl << endl;
	system("pause");
}